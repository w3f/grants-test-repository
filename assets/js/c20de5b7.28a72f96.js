"use strict";(self.webpackChunkgrants=self.webpackChunkgrants||[]).push([[1053],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>u});var n=a(67294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=c(a),u=o,m=h["".concat(s,".").concat(u)]||h[u]||d[u]||r;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function u(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},27462:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var n=a(87462),o=(a(67294),a(3905));const r={},i="Ruby Protocol - Open Grants Program",l={unversionedId:"Applications/RubyProtocol",id:"Applications/RubyProtocol",isDocsHomePage:!1,title:"Ruby Protocol - Open Grants Program",description:"- Project: Ruby Protocol",source:"@site/docs/Applications/RubyProtocol.md",sourceDirName:"Applications",slug:"/Applications/RubyProtocol",permalink:"/grants-test-repository/docs/Applications/RubyProtocol",editUrl:"https://github.com/w3f/grants-test-repository/edit/master/docs/Applications/RubyProtocol.md",tags:[],version:"current",lastUpdatedBy:"Sebastian M\xfcller",lastUpdatedAt:1667994768,formattedLastUpdatedAt:"11/9/2022",frontMatter:{},sidebar:"defaultSidebar",previous:{title:"W3F Grant Proposal",permalink:"/grants-test-repository/docs/Applications/RubeusKeeper"},next:{title:"Open Grant Proposal",permalink:"/grants-test-repository/docs/Applications/SEOR-code-less-smart-contract-platform"}},s=[{value:"Project Overview \ud83d\udcc4",id:"project-overview-",children:[{value:"Overview",id:"overview",children:[]},{value:"Project Details",id:"project-details",children:[]}]},{value:"Team \ud83d\udc65",id:"team-",children:[{value:"Team Members",id:"team-members",children:[]},{value:"Team Website",id:"team-website",children:[]},{value:"Legal Structure",id:"legal-structure",children:[]},{value:"Team Experience",id:"team-experience",children:[]},{value:"Team Code Repos",id:"team-code-repos",children:[]},{value:"Team Linkedin Profiles",id:"team-linkedin-profiles",children:[]}]},{value:"Development Roadmap \ud83d\udd29",id:"development-roadmap-",children:[{value:"Overview",id:"overview-1",children:[]},{value:"Community Engagement",id:"community-engagement",children:[]}]},{value:"Future Plans",id:"future-plans",children:[]},{value:"Additional Information \u2795",id:"additional-information-",children:[{value:"Reference",id:"reference",children:[]}]}],c={toc:s};function p(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"ruby-protocol---open-grants-program"},"Ruby Protocol - Open Grants Program"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Project:")," Ruby Protocol"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Proposer:")," Ruby Protocol"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Payment Address:")," 0x5aBBe7b65c572b9f5Cc7655Ba4a1Acad0e892720")),(0,o.kt)("h2",{id:"project-overview-"},"Project Overview \ud83d\udcc4"),(0,o.kt)("h3",{id:"overview"},"Overview"),(0,o.kt)("h4",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"This project will design and implement a fine-grained personal data monetization framework, which would serve as a second-layer/middleware protocol interacting with the substrate module. The framework will enable a data owner to enforce a fine-grained access control policy over his/her encrypted private data using functional encryption, and share predefined computation results over the private data with a data purchaser in exchange for economic compensation. The access control policy will be built into the substrate module, and the data monetization transaction will also execute via substrate module, which is why this solution is defined as a second-layer/middleware protocol."),(0,o.kt)("h3",{id:"project-details"},"Project Details"),(0,o.kt)("h4",{id:"project-architecture"},"Project Architecture"),(0,o.kt)("p",null,"Functional encryption was originally proposed as a fine-grained access control mechanism over encrypted data ","[GPSW06]",". A data owner encrypts a message ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," to generate ciphertext, which could be stored in an untrusted cloud server. The project might pay for the hosting expenses initially to jump-start the project, but we will gradually transfer the cost to the data owner since it would make sense for them to pay for their data monetization business. A data purchaser might wish to compute a function ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," over the encrypted message. With the consent of the data owner, a data purchaser would receive a secret key ",(0,o.kt)("inlineCode",{parentName:"p"},"sk_f")," from a key distributor. The data purchaser can then use the private key ",(0,o.kt)("inlineCode",{parentName:"p"},"sk_f"),"  to decrypt the ciphertext to compute ",(0,o.kt)("inlineCode",{parentName:"p"},"f(x)"),". Note the data purchaser cannot retrieve any other information on the underlying message except the final decryption result ",(0,o.kt)("inlineCode",{parentName:"p"},"f(x)"),". To prevent the data owner from accepting payment and then immediately removing their data from the cloud before the data purchaser receives the data, the data purchaser needs to retrieve the encrypted data before paying the owner."),(0,o.kt)("p",null,"Here is a more concrete example for functional encryption: the message here could be the user\u2019s genomic data, and ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," could be a statistical analysis algorithm. The data purchaser could be a research institute intended to perform private statistical analysis over one\u2019s genomic data. The secret key might be generated by the hospital that collects the users' genomic data or the data owner themselves. At the end of this transaction, the data owner will receive economic compensation for one's contribution to the computation result while the data purchaser will receive the statistical analysis results. In other cases, the data could also be one\u2019s social network data and the function could be an analytics algorithm for online advertisement. We envision the monetary exchange between the data owner and purchaser will be executed as a substrate module."),(0,o.kt)("p",null,"This project will implement a second-layer/middleware protocol running on Polkadot that enables individuals to monetize their private data in a fine-grained fashion. The delivery will include:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A cryptographic library that implements the inner product functional encryption and quadratic polynomial functional encryption."),(0,o.kt)("li",{parentName:"ul"},"A substrate module that implements the encryption of the cryptographic keys of the functional encryption scheme and the associated zero-knowledge proof for its legitimacy."),(0,o.kt)("li",{parentName:"ul"},"A micropayment scheme running on the Polkadot blockchain can allow individual users to monetize their data.")),(0,o.kt)("p",null,"Here are the basic principles behind the overall architecture design of the fine-grained personal data monetization framework. We aim to keep the workload of the data owner minimum. This implies the online time of the data owner should be kept to a minimum. The optimal case would be the data owner is left alone after he generates and uploads the ciphertext. Ideally, the encryption workload of the data owner should also be kept as minimal as possible. The following scheme can be viewed as a generalization of the knowledge monetization scheme proposed in ","[TZLHJS2017]","."),(0,o.kt)("p",null,"The general idea is shown in Fig. 1. A functional encryption scheme usually consists of four algorithms:",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Setup(1^\\lambda)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.KeyGen(msk, f)"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Enc(mpk, x)")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Decrypt(Key_f, FE.Enc(mpk, x))"),". At the beginning of the system, the key distributors run the ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Setup(1^\\lambda)")," algorithm to generate the master public key ",(0,o.kt)("inlineCode",{parentName:"p"},"mpk")," and master secret key ",(0,o.kt)("inlineCode",{parentName:"p"},"msk"),". Here ",(0,o.kt)("inlineCode",{parentName:"p"},"\\lambda")," denotes the security parameter. When a data owner wishes to sell his data, he encrypts his data ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," by running the ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Enc(mpk, x)")," algorithm and uploads the output ciphertext ",(0,o.kt)("inlineCode",{parentName:"p"},"Enc(x)")," to the untrusted cloud. He then specifies the pricing model with respect to different functions ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),"\u2019s in a substrate module SC, and posts it to the Polkadot blockchain. When a data purchaser intends to calculate ",(0,o.kt)("inlineCode",{parentName:"p"},"f(x)"),", he will first generate a commitment of an appropriate amount of coin based on the pricing of the function ",(0,o.kt)("inlineCode",{parentName:"p"},"f")," and his own public key ",(0,o.kt)("inlineCode",{parentName:"p"},"PK_P")," as a transaction to call the module SC."),(0,o.kt)("div",{align:"center"},(0,o.kt)("img",{src:"https://user-images.githubusercontent.com/10559375/111019184-861b5b80-83f8-11eb-8cea-e15f1ef1d146.gif",alt:"",width:"70%"})),(0,o.kt)("p",null,"The substrate module should return a receipt to the data purchaser, who will in turn present it to the key distributor. The key distributor, after verifying the receipt and the respective coin commitment, runs the ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.KeyGen(msk, f)")," algorithm to generate the function key ",(0,o.kt)("inlineCode",{parentName:"p"},"Key_f")," for the data purchaser."),(0,o.kt)("p",null,"Simultaneously, the distributor will send SC the encryption of ",(0,o.kt)("inlineCode",{parentName:"p"},"Key_f")," under the data purchaser\u2019s public key ",(0,o.kt)("inlineCode",{parentName:"p"},"PK_P"),", denoted as ",(0,o.kt)("inlineCode",{parentName:"p"},"Enc_(PK_P)(Key_f)")," and an associated zero-knowledge proof proving ",(0,o.kt)("inlineCode",{parentName:"p"},"Key_f")," is indeed a well-formed function key corresponding to ",(0,o.kt)("inlineCode",{parentName:"p"},"f"),". SC with the inputs from both the key distributor and data purchaser is then verified by the Polkadot blockchain. Once the verification for both sides passes, meaning the amount of the committed coin is sufficient to pay for the decryption result ",(0,o.kt)("inlineCode",{parentName:"p"},"f(x)")," and the gas fee, and the associated zero-knowledge proof is correct, the payment will be released to the data owner. The data purchaser can then download the ciphertext and decrypt ",(0,o.kt)("inlineCode",{parentName:"p"},"f(x)")," by running the ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Decrypt(Key_f, FE.Enc(mpk, x))")," algorithm."),(0,o.kt)("p",null,"Note once the verification of SC is passed, SC will execute and payment is released to the data owner instantaneously. To ensure fairness towards the data purchaser, the data owner should provide verifiable evidence to prove his data source. ",(0,o.kt)("inlineCode",{parentName:"p"},"FE.Enc(x)")," is accompanied by a certified signature ",(0,o.kt)("inlineCode",{parentName:"p"},"Sig_D(FE.Enc(x))")," to prove the data is coming from the right source and thus the data quality can be guaranteed. Here D denotes the private key of the data source. The data source could charge an extra service fee from the data owner when the data owner first meets the data source (goes to the hospital and does the test in the genomic computation example) and decides to join the monetization program. We note even though the data source (the hospital in the genomic computation example) is the one that produces the data, it doesn't necessarily mean that it owns the patients' data. For instance, according to ",(0,o.kt)("a",{parentName:"p",href:"https://www.forbes.com/sites/forbestechcouncil/2018/04/23/who-really-owns-your-health-data/?sh=1499f91d6d62"},"this report"),", some states in the US explicitly give patients ownership of their health data. In other words, only the patient can dictate how the data should be monetized. Although it might be tempting to let the data source be representative of the data owners and handle the monetization of their private data, it would both go against both the law and the ethos of the project, which is to put the control of one's data back in the hands of the owner."),(0,o.kt)("p",null,"The design of the underlying functional encryption scheme, where the private key should correspond to the function chosen by the data purchaser. Since the encryption of the private key should be presented as evidence (as shown in Fig. 1) and verified on the blockchain, the private key should be of minimum size, preferably constant size. To keep the workload of both the data owner and key distributor minimal, the encryption time and key generation time should be as short as possible."),(0,o.kt)("p",null,"There exist several functional encryption schemes with constant key size such as the one presented in ","[SC2017,CRH2015, RDGBP2019,B2017,MSHBM2019]",". General predicate encryption allows the data owner to encrypt the raw data items tagged with various attributes, and a data purchaser to query different parts of the data repository using a function key corresponding to a predicate. Inner product predicate encryption ","[CGW2015]"," is a special kind of predicate encryption, where the data purchaser could retrieve the data records if the inner product of their attribute vector ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," and the predicate vector ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," specified by the data purchaser is equal to 0. For instance, the data purchaser could potentially ask for the data records corresponding to a conjunctive predicate such as \u201cAge\u201dAND\u201cgender\u201dAND\u201cIncome\u201d from a personal data repository. One of the most efficient inner product encryption schemes ","[CGW2015]"," has a private key consisting of four elliptic curve group elements, and its key generation is dominated by four modular exponentiations."),(0,o.kt)("p",null,"While the predicate encryption allows the data purchaser to retrieve different parts of a database based on a predefined predicate, a more general functional encryption allows the data purchaser to calculate an arbitrary function over the input ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),". This project will focus on a slightly narrow set of functional encryption schemes: inner product encryption and quadratic polynomial function encryption ","[MSHBM2019]",". In an inner product encryption scheme, for encryption of a vector ",(0,o.kt)("inlineCode",{parentName:"p"},"x"),", the data purchaser with a private key corresponding to another vector ",(0,o.kt)("inlineCode",{parentName:"p"},"y")," will be able to compute the inner product between ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"y"),". On the other hand, in a quadratic polynomial functional encryption scheme, the data owner will encrypt two vectors ",(0,o.kt)("inlineCode",{parentName:"p"},"v_1 \\in \\mathbb{Z}_n")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"v_2 \\in \\mathbb{Z}_n"),", a data purchaser with a secret key corresponding to a matrix ",(0,o.kt)("inlineCode",{parentName:"p"},"H \\in \\mathbb{Z}^{n*n}")," is allowed to decrypt the quadratic product of ",(0,o.kt)("inlineCode",{parentName:"p"},"x_1, x_2"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"H"),", i.e., ",(0,o.kt)("inlineCode",{parentName:"p"},"x_1^T\\cdot H \\cdot x_2"),". Both inner product encryption and quadratic polynomial functional encryption can support sophisticated privacy-preserving machine learning tasks, such as classification ","[LCFS2017,SGP2018]"," and neural networks ","[RDGBP2019]","."),(0,o.kt)("p",null,"The benchmark results for various inner product encryption and quadratic polynomial function encryption schemes can be found in ","[MSHBM2019]",". The private key of inner product encryption consists of one elliptic curve group element, which is of 256 bits under 128-bit level security. The key generation for a vector of 100 elements takes 0.4149s, and the encryption time for the data owner is around 0.2103s for a vector of the same size. The private key of quadratic polynomial functional encryption also only consists of one elliptic curve group element. The average key generation and encryption time for each coordinate of the message vector is 0.001s and 0.025s."),(0,o.kt)("p",null,"In terms of the accompanied zero-knowledge proof scheme, the statement of the zero-knowledge proof scheme should be to convince the verifier that the encrypted content is a well-formed function key with regards to a predefined function in the module. Since the verification of the zero-knowledge proof should be verified by the blockchain, we need to make sure the verification is efficient and the proof size is as small as possible. The candidate zero-knowledge proof scheme for this is zk-snark implementation such as ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zeropoolnetwork/zeropool-substrate"},"ZeroPool"),", which is an implementation of Groth16 scheme. The proof generation time is comparatively short for the previously mentioned encryption schemes since the respective statement (determined by the key generation algorithm and the public key encryption) is quite simple."),(0,o.kt)("p",null,"According to the pricing model of data monetization, a report presented by OECD ","[RRS2013]"," classifies the existing practical pricing models of personal data into two major categories: based on market valuation and individual valuation. The approach based on individual valuation suffers from the defect that the individual valuation of the private data is extremely context-dependent and cannot be measured with precision and certainty. The market-valuation-based approach can be further divided into the following sub-categories: market cap per data record, market prices for data, cost of a data breach, and data prices in illegal markets."),(0,o.kt)("p",null,"The approach based on market prices for data is particularly interesting given that data brokers usually publicly broadcast their asking prices for various personal data records. Our platform can easily aggregate and compare across various data brokers to use it as the proxy pricing model of the individual personal data record. One could further refine these data prices based on the queried function and adopt a fine-grained pricing approach used by DirectMail ","[MDJM2019]",". They give an example where the base price per record is equal to $0.045 and the predicate-based price per record is equal to $0.0035 + $0 + $0.004 = $0.0075 (for example, calculated from the aforementioned conjunctive predicate). Thus, the total price per record for predicate encryption would be equal to $0.045 + $0.0075 = $0.0525. For the inner product encryption or quadratic polynomial function encryption, the price of the decryption result will exclude the base price of the record."),(0,o.kt)("p",null,"This will be one of the pricing strategies we adopt in phase 1 and phase 2 of our project. In the later development of our project, we will explore more algorithmic pricing approaches such as Automated Market Maker\u2019s (AMMs), where the platform estimates how much the data purchaser is willing to pay for data of different qualities and determines the concrete data pricing model."),(0,o.kt)("h4",{id:"team-interest"},"Team Interest"),(0,o.kt)("p",null,"The Ruby Protocol team consists of seasoned engineers, cryptographers, data scientists and  cryptocurrency early adopters. Our team has a very deep understanding of data monetization and zero-knowledge algorithms. The expertise in cryptography has allowed us to deliver impressive results  The background of the team consists of both engineering and academic backgrounds. We believe that Decentralized Data (DeData) will be the next massive adoption market after Decentralized Finance (DeFi)."),(0,o.kt)("h5",{id:"substratepolkadot-integration"},"Substrate/Polkadot Integration"),(0,o.kt)("p",null,"We will leverage the existing cryptographic library in the Polkadot ecosystem, such as ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/zeropoolnetwork/zeropool-substrate"},"ZeroPool")," to build the underlying cryptographic library that implements the zero-knowledge proof for the legitimacy of the encrypted functional key. We will also integrate the existing inner product functional encryption and quadratic polynomial functional encryption with the Polkadot ecosystem. Furthermore, we will also build a substrate pallet that integrates the verification logic of the associated zero-knowledge proof and provide the necessary UI for the users to interact with all these algorithms and invoke the aforementioned cryptographic modules and the micropayment scheme."),(0,o.kt)("h5",{id:"open-api-and-sdk"},"Open API and SDK"),(0,o.kt)("p",null,"The ultimate goal of Ruby Protocol is to provide an essential open API and SDK from a high-level perspective with the above tools, fully powering the data monetization framework on Polkadot, including:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A cryptographic library that implements the inner product functional encryption and quadratic polynomial functional encryption. A substrate module that integrates the verification logic of the associated zero-knowledge proof for the legitimacy of the encrypted functional key."),(0,o.kt)("li",{parentName:"ul"},"The client can trigger the aforementioned cryptographic modules and the micropayment scheme and the necessary UI to enable the users to interact with all these algorithms.")),(0,o.kt)("h4",{id:"ecosystem-fits"},"Ecosystem Fits"),(0,o.kt)("p",null,"The existing internet economic model relies almost exclusively on the monetization of personal data. The recent scandals on the internet companies mishandling individual data such as Facebook\u2019s Cambridge Analytica scandal have prompted many individuals to awaken to the fact that in the current internet economy they are the product and they need to regain control over their data. In fact, I would argue that the recently published privacy regulation such as GDPR or CCPA is the response to this urge."),(0,o.kt)("p",null,"Polkadot could act as an indispensable role to remove the middleman of the internet economy. A second-layer fine-grained personal data monetization framework based on Polkadot would potentially move Polkadot beyond a decentralized financial platform and enable Polkadot to play a central role in the next-generation data economy. It would also enable Polkadot to gain a moral high ground by freeing billions of web users from the control of monopoly middleman companies."),(0,o.kt)("p",null,"The following is the reason why a cross-chain platform such as Polkadot is a perfect platform to implement a decentralized and transparent data monetization mechanism:\nThe monetary return of one single data monetization transaction tends to be small. The economic benefit to the data owner can only be noticeable when this type of micropayment happens frequently. However, the mental cost incurred by having to deal with frequent micropayment might render it undesirable. Substrate module as publicly verifiable, self-enforcing code could help amortize the mental cost."),(0,o.kt)("p",null,"The substrate module will specify the types of computation the data purchaser is allowed to perform over the ciphertext. Since the same computation result could be of different values to different data purchasers, automatic payment based on substrate module could be used to enforce sophisticated pricing models to guarantee the maximum economic return for the data owner."),(0,o.kt)("p",null,"A publicly verifiable substrate module would not only help with the transparent enforcement of various privacy regulations such as General data protection regulation (GDPR) or California consumer privacy act (CCPA) but also ensure the fairness of data monetization transactions without the involvement of any middleman ","[TZLHJS17]",". This is in stark contrast with the opaque business model of the existing internet economy where giant internet companies absorb all the economic benefits of personal data monetization. Our framework will let individuals regain control of their private data."),(0,o.kt)("p",null,"We all know the slogan \u201cData is the new oil\u201d. According to alliedmarketresearch.com, the global data monetization market size was valued at $44869 in 2016, and is projected to reach at $370969 million by 2023, growing at a CAGR of 35.4% from 2017 to 2023. Even by capturing a small piece of this market, it would bring enormous economic benefits to the Polkadot ecosystem."),(0,o.kt)("p",null,"A second-layer fine-grained data monetization framework will also greatly expand the Polkadot community through attracting not only privacy-conscious users but also business partners hunger for high-quality data such as research institutes, hospitals, traditional financial institutes, etc."),(0,o.kt)("p",null,"There are three relevant projects: the first one is perhaps the Enigma project, a privacy protocol that enables the creation of decentralized applications that guarantee privacy. The protocol Enigma bases on is secure multi-party computation (MPC). The second one, Insights Network is a data exchange based on combining blockchain technology, substrate module, and MPC. It is based on the EOS blockchain and a custom MPC system. The third one, NuCypher is a cryptographic infrastructure for privacy-preserving applications. Its main technology is threshold proxy re-encryption and fully homomorphic encryption. None of these second-layer protocols are built for the Polkadot ecosystem."),(0,o.kt)("p",null,"There are several different ways of implementing an MPC protocol: threshold homomorphic encryption, garbled circuit, and secret sharing. The general idea of MPC is to outsource private data (either in the form of secret shares or homomorphic encryption) to a few separate computing parties so that they can perform confidential computation over the encrypted data. Directly applying MPC to fine-grained personal data monetization is problematic in the sense that once the data is outsourced, the data owner does not exert any control over what type of computation can be performed by the computing party. In other words, individual privacy is now at the mercy of these computing parties, which is against the human-centric ethos of fine-grained personal data monetization, where the access control policy should be defined by the data owner and enforced by the algorithm.   On the other hand, functional encryption was specifically proposed and tailored for enforcing fine-grained access control over encrypted data. By allowing the data owner to define the access control policy, the owner has full control over what type of access the data purchaser can have over the encrypted personal data. The only decryption result the data purchaser will be able to retrieve is the predefined function evaluation."),(0,o.kt)("h2",{id:"team-"},"Team \ud83d\udc65"),(0,o.kt)("h3",{id:"team-members"},"Team Members"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"David Spade - Full-stack Software Engineer"),(0,o.kt)("li",{parentName:"ul"},"Kevin Hsu - Data Scientist"),(0,o.kt)("li",{parentName:"ul"},"Dylan Dewdney - Marketing Advisor"),(0,o.kt)("li",{parentName:"ul"},"Beni Issembert - Strategy Advisor")),(0,o.kt)("h3",{id:"team-website"},"Team Website"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://rubyprotocol.com/"},"http://rubyprotocol.com/"))),(0,o.kt)("h3",{id:"legal-structure"},"Legal Structure"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Ruby Technology Ltd. is a company registered in the Cayman Islands.")),(0,o.kt)("h3",{id:"team-experience"},"Team Experience"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"David Spade"),(0,o.kt)("br",{parentName:"p"}),"\n","David Spade graduated from the University of Nottingham. He is a full-stack developer with 8 years of experience in software development. David also has deep knowledge in zero-knowledge algorithms and he is an expert in data science."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Kevin Hsu"),(0,o.kt)("br",{parentName:"p"}),"\n","Kevin Hsu graduated from MSc in Computational Statistics and Machine Learning from UCL and was supervised by David Silver, the senior engineer of AlphaGO. He served as a data scientist in Credit Suisse, senior machine learning Engineer in WeCash. Prescient and consistent track-record in investment and has invested in over 160 blockchain projects around the world."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Beni Issembert"),(0,o.kt)("br",{parentName:"p"}),"\n","Beni Issembert is a former Beam Privacy CMO, and currently works as Concordium CMO (a Proof-of-stake for businesses backed by IKEA, Volvo,and Geely). He has a Ph.D. in Philosophy of Sciences from John Hopkins and has been working in the digital world as an entrepreneur since 2005. Beni is a published author and respected thought leader in Blockchain, specifically within areas of privacy and identity."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Dylan Dewdney"),(0,o.kt)("br",{parentName:"p"}),"\n","Dylan Dewdney is a longtime crypto enthusiast (2011). In 2017 he co-founded Harbour DAO, which became an open-standard set of tools for building governance structures and voting mechanisms on ERC-20. Later, as Chief Evangelist of Beam and Head of Growth for AdEx, he was a key part of their GTM and general growth strategies. Dylan is a respected peer among many different projects and areas of business.Dylan is also the project lead and CEO of DeData project Kylin Network."),(0,o.kt)("h3",{id:"team-code-repos"},"Team Code Repos"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/Ruby-Protocol"},"https://github.com/Ruby-Protocol"))),(0,o.kt)("h3",{id:"team-linkedin-profiles"},"Team Linkedin Profiles"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://www.linkedin.com/in/dylan-dewdney"},"www.linkedin.com/in/dylan-dewdney"))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://www.linkedin.com/in/beniissembert"},"www.linkedin.com/in/beniissembert")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"http://www.linkedin.com/in/yingkaixu"},"www.linkedin.com/in/yingkaixu"))),(0,o.kt)("h2",{id:"development-roadmap-"},"Development Roadmap \ud83d\udd29"),(0,o.kt)("h3",{id:"overview-1"},"Overview"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Total Estimated Duration:")," 2 months")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Full-time equivalent (FTE):")," 3 FTE"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Total Costs:")," 30,000 DAI")),(0,o.kt)("h4",{id:"milestone-1--implement-cryptographic-modules"},"Milestone 1 \u2014 Implement Cryptographic Modules"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Estimated Duration:")," 5 months")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"FTE:")," 1"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Costs:")," 10K DAI")),(0,o.kt)("p",null,"The main deliverable of this milestone includes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A cryptographic library written in Rust that implements the inner product functional encryption and quadratic polynomial functional encryption.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"A substrate pallet that integrates the verification logic of the associated zero-knowledge proof for the legitimacy of the encrypted functional key."))),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Number")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Deliverable")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Specification")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0a."),(0,o.kt)("td",{parentName:"tr",align:null},"License"),(0,o.kt)("td",{parentName:"tr",align:null},"Apache License 2.0")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0b."),(0,o.kt)("td",{parentName:"tr",align:null},"Documentation"),(0,o.kt)("td",{parentName:"tr",align:null},"We will provide both inline documentation of the code and a basic tutorial that explains how a user can (for example) spin up one of our Substrate nodes. Once the node is up, it will be possible to send test transactions that will show how the new functionality works.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0c."),(0,o.kt)("td",{parentName:"tr",align:null},"Testing Guide"),(0,o.kt)("td",{parentName:"tr",align:null},"Core functions will be fully covered by unit tests to ensure functionality and robustness. In the guide, we will describe how to run these tests.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0d."),(0,o.kt)("td",{parentName:"tr",align:null},"Article/Tutorial"),(0,o.kt)("td",{parentName:"tr",align:null},"We will publish a medium article that explains the functionality of the proposed cryptographic library and substrate pallet delivered in this milestone.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1."),(0,o.kt)("td",{parentName:"tr",align:null},"Cryptographic modules"),(0,o.kt)("td",{parentName:"tr",align:null},"We will implement the cryptographic modules including inner product functional encryption and quadratic polynomial functional encryption ","[MSHBM2019]"," and the associated zero-knowledge proof ","[ZeroPool]",". The cryptographic modules will be written in Rust and modified from the ",(0,o.kt)("a",{parentName:"td",href:"https://github.com/dev0x1/functional-encryption-schemes"},"rust version")," of ",(0,o.kt)("a",{parentName:"td",href:"https://github.com/fentec-project/CiFEr"},"CiFEr library"),". We will build privacy-preserving classification and neural networks based on these modules. We will also implement a substrate pallet that integrates the verification logic of the associated zero-knowledge proof for the legitimacy of the encrypted functional key.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"2."),(0,o.kt)("td",{parentName:"tr",align:null},"Benchmark"),(0,o.kt)("td",{parentName:"tr",align:null},"Perform unit tests on the individual algorithms to ensure their safety. Benchmark on the gas cost and throughput of the proposed module.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"3."),(0,o.kt)("td",{parentName:"tr",align:null},"Docker"),(0,o.kt)("td",{parentName:"tr",align:null},"We will provide a dockerfile to demonstrate the usage of our modules.")))),(0,o.kt)("h4",{id:"milestone-2--client-implementation-and-integration"},"Milestone 2 \u2014\u2014 Client Implementation and Integration"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Estimated Duration:")," 1 month"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"FTE:")," 2"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Costs:")," 20K DAI")),(0,o.kt)("p",null,"The main deliverable of the milestone is the client that can trigger the aforementioned cryptographic modules and the micropayment scheme and the necessary UI to enable the users to interact with all these algorithms."),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Number")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Deliverable")),(0,o.kt)("th",{parentName:"tr",align:null},(0,o.kt)("strong",{parentName:"th"},"Specification")))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0a."),(0,o.kt)("td",{parentName:"tr",align:null},"License"),(0,o.kt)("td",{parentName:"tr",align:null},"Apache License 2.0")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0b."),(0,o.kt)("td",{parentName:"tr",align:null},"Documentation"),(0,o.kt)("td",{parentName:"tr",align:null},"We will provide both inline documentation of the code and a basic tutorial that explains how a user can (for example) spin up one of our Substrate nodes. Once the node is up, it will be possible to send test transactions that will show how the new functionality works.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0c."),(0,o.kt)("td",{parentName:"tr",align:null},"Testing Guide"),(0,o.kt)("td",{parentName:"tr",align:null},"Core functions will be fully covered by unit tests to ensure functionality and robustness. In the guide, we will describe how to run these tests.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"0d."),(0,o.kt)("td",{parentName:"tr",align:null},"Article/Tutorial"),(0,o.kt)("td",{parentName:"tr",align:null},"We will publish a medium article that explains the functionality of the proposed client and UI delivered in this milestone.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"1."),(0,o.kt)("td",{parentName:"tr",align:null},"Client modules"),(0,o.kt)("td",{parentName:"tr",align:null},"We will implement the client to support the key distribution and decryption of the functional encryption scheme ","[MSHBM2019]",". The client will also generate the transaction that can trigger the aforementioned cryptographic modules and the micropayment scheme ","[MDJM2019]",", such as the encrypted functional key and zero-knowledge proof. We will provide a basic UI to take inputs from the users for all these algorithms and receive the outputs. More specifically, the UI will enable the data owner to input the raw data to generate the signed ciphertext and upload it to the cloud server. The UI will also allow the data purchaser to retrieve the functional key from the key authority and the ciphertext from the cloud and then perform the decryption. The UI will also register a qualified data source and allow a data owner to join the data monetization program when he/she meets the data source and the data owners to request a signature from a registered source, which will then be verified on-chain. Finally, it will also allow these entities to interact with the substrate module with the inputs and outputs defined in our architecture.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"2."),(0,o.kt)("td",{parentName:"tr",align:null},"Benchmark"),(0,o.kt)("td",{parentName:"tr",align:null},"Perform unit tests on the individual algorithms to ensure their safety. Benchmark on the latency and usability of the proposed client functionalities.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"3."),(0,o.kt)("td",{parentName:"tr",align:null},"Docker"),(0,o.kt)("td",{parentName:"tr",align:null},"We will provide a dockerfile to demonstrate the usage of our modules.")))),(0,o.kt)("h3",{id:"community-engagement"},"Community Engagement"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Bounty Program for General Community:")," We will reward users who contribute positively to community building and content creation through an Ambassador Program. The community management team will be available 24/7 to answer questions.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Incentive Program for Data Monetization:")," After the main functions are completed, we will provide incentives for users to monetize their data on our platform. This is an encouragement for users to provide the data and purchase the data."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Parachain Loan Offering Campaign:")," We may hold a Parachain Loan Offering and reward users for helping our auction with Ruby Protocol tokens."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Affiliated Program of Cryptographic Infrastructure:")," It is proven effective for user growth and can be integrated into Ruby\u2019s cryptographic infrastructure.")),(0,o.kt)("h2",{id:"future-plans"},"Future Plans"),(0,o.kt)("p",null,"We will hire at least 8-10 more devs in the next three months. Meanwhile, we will apply for the Substrate Builder's Program. After that, Ruby Protocol wants to become a parachain for the Polkadot network. We have some preparations for auction and we may design a community-wide LPO."),(0,o.kt)("p",null,"In phase 1, we will complete the implementation of cryptographic modules as a substrate pallet that integrates the verification logic of the associated zero-knowledge proof for the legitimacy of the encrypted functional key."),(0,o.kt)("p",null,"In phase 2, our goal is to deliver the micropayment scheme and enable the users to interact with all these algorithms in a working product."),(0,o.kt)("p",null,"Finally, our goal is to provide an essential open API and SDK from a high-level perspective with the above tools, fully powering the data monetization framework on Polkadot."),(0,o.kt)("h2",{id:"additional-information-"},"Additional Information \u2795"),(0,o.kt)("h3",{id:"reference"},"Reference"),(0,o.kt)("p",null,"[GPSW06]"," Goyal, V., Pandey, O., Sahai, A., & Waters, B. (2006, October). Attribute-based encryption for fine-grained access control of encrypted data. In Proceedings of the 13th ACM conference on Computer and communications security (pp. 89-98)."),(0,o.kt)("p",null,"[GGGJKLZ14]"," Goldwasser, S., Gordon, S. D., Goyal, V., Jain, A., Katz, J., Liu, F. H., ... & Zhou, H. S. (2014, May). Multi-input functional encryption. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (pp. 578-602). Springer, Berlin, Heidelberg."),(0,o.kt)("p",null,"[GKPVZ13]"," Goldwasser, S., Kalai, Y., Popa, R. A., Vaikuntanathan, V., & Zeldovich, N. (2013, June). Reusable garbled circuits and succinct functional encryption. In Proceedings of the forty-fifth annual ACM symposium on Theory of computing (pp. 555-564)."),(0,o.kt)("p",null,"[ALS2016]"," Agrawal, S., Libert, B., Stehle, D.: Fully secure functional encryption for inner products, from standard assumptions. In: Annual International Cryptology Conference. pp. 333{362. Springer (2016)."),(0,o.kt)("p",null,"[B2017]"," Bourse, F. (2017). Functional encryption for inner-product evaluations (Doctoral dissertation)."),(0,o.kt)("p",null,"[B2018]"," Vitalik Buterin,\n",(0,o.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477"},"https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477"),",\n2018."),(0,o.kt)("p",null,"[BCTV2013]"," Eli Ben-Sasson, Alessandro Chiesa, Eran Tromer, and Madars Virza. Succinct non-interactive zero knowledge for a von Neumann architecture. In Proceedings of the 23rd USENIX Security Symposium, Security '14. Available at ",(0,o.kt)("a",{parentName:"p",href:"http://eprint.iacr.org/2013/879"},"http://eprint.iacr.org/2013/879"),"."),(0,o.kt)("p",null,"[BMEB2016]"," Bataineh, A. S., Mizouni, R., El Barachi, M., & Bentahar, J. (2016, June). Monetizing Personal Data: A Two-Sided Market Approach. In ANT/SEIT (pp. 472-479)."),(0,o.kt)("p",null,"[CGW2015]"," Chen, J., Gay, R., & Wee, H. (2015, April). Improved dual system ABE in prime-order groups via predicate encodings. In Annual International Conference on the Theory and Applications of Cryptographic Techniques (pp. 595-624). Springer, Berlin, Heidelberg."),(0,o.kt)("p",null,"[FVBG17]"," Fisch, B., Vinayagamurthy, D., Boneh, D., & Gorbunov, S. (2017, October). Iron: functional encryption using Intel SGX. In Proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security (pp. 765-782)."),(0,o.kt)("p",null,"[LCFS2017]"," Ligier, D., Carpov, S., Fontaine, C., & Sirdey, R. (2017, February). Privacy Preserving Data Classification using Inner-product Functional Encryption. In ICISSP (pp. 423-430)."),(0,o.kt)("p",null,"[MDJM2019]"," Mehta, S., Dawande, M., Janakiraman, G., & Mookerjee, V. (2019). How to sell a dataset? pricing policies for data monetization. Pricing Policies for Data Monetization (August 1, 2019)."),(0,o.kt)("p",null,"[MSHBM2019]"," Marc, T., Stopar, M., Hartman, J., Bizjak, M., & Modic, J. (2019, September). Privacy-Enhanced Machine Learning with Functional Encryption. In European Symposium on Research in Computer Security (pp. 3-21). Springer, Cham."),(0,o.kt)("p",null,"[PHGR2013]"," Parno, B., Howell, J., Gentry, C., & Raykova, M. (2013, May). Pinocchio: Nearly practical verifiable computation. In 2013 IEEE Symposium on Security and Privacy (pp. 238-252). IEEE."),(0,o.kt)("p",null,"[RDGBP2019]"," Ryffel, T., Dufour-Sans, E., Gay, R., Bach, F., & Pointcheval, D. (2019). Partially encrypted machine learning using functional encryption. arXiv preprint arXiv:1905.10214."),(0,o.kt)("p",null,"[RRS2013]"," Reimsbach-Kounatze, C., Reynolds, T., & Stryszowski, P. (2013). Exploring the economics of personal data-a survey of methodologies for measuring monetary value."),(0,o.kt)("p",null,"[SC2017]",' Agrawal, Shashank, and Melissa Chase. "Simplifying design and analysis of complex predicate encryption schemes." Annual International Conference on the Theory and Applications of Cryptographic Techniques. Springer, Cham, 2017.   ',"[SGP2018]"," Sans, E.D., Gay, R., Pointcheval, D.: Reading in the dark: Classifying encrypted digits with functional encryption. IACR Cryptology ePrint Archive 2018, 206, (2018)."),(0,o.kt)("p",null,"[TZLHJS2017]"," Florian Tramer, Fan Zhang, Huang Lin, Jean-Pierre Hubaux, Ari Juels, and Elaine Shi. \u201dSealed-glass proofs: Using transparent enclaves to prove and sell knowledge.\u201d In Security and Privacy (EuroS&P), 2017 IEEE European Symposium on, pp. 19-34. IEEE, 2017."))}p.isMDXComponent=!0}}]);